import pygame
import sys
import threading
import json
import requests
import re
import mysql.connector
import os
from datetime import datetime

pygame.init()
pygame.mixer.init()  # ××ª×—×•×œ ×”Ö¾mixer ×©×œ Pygame ×œ×¦×•×¨×š × ×™×’×•×Ÿ ×¡××•× ×“


class TriviaModel:
    """
    ××—×œ×§×” ×–×• (Model) ×× ×”×œ×ª ××ª ××¦×‘ ×”××©×—×§ (Game State) ×•××ª ×”×œ×•×’×™×§×” ×”×¢×¡×§×™×ª:
    - ×’×™×©×” ×œ××¡×“ ×”× ×ª×•× ×™× (CRUD ×¢×‘×•×¨ × ×™×§×•×“).
    - ×©××™×¨×” ×•×˜×¢×™× ×” ×©×œ ×©××œ×•×ª (×Ö¾API ××• ×××˜××•×Ÿ).
    - × ×™×”×•×œ ×§×˜×’×•×¨×™×•×ª, ×©××œ×•×ª ×©×›×‘×¨ × ×¦×¤×•, ×ª×™×¢×•×“ ×›×™×©×œ×•× ×•×ª ×•×¢×•×“.
    - ×”×’×“×¨×ª ××©×ª× ×™ ××©×—×§ ×›××• ××¡×¤×¨ ×©××œ×•×ª ×œ×§×˜×’×•×¨×™×”, × ×™×§×•×“ × ×•×›×—×™, ×§×˜×’×•×¨×™×” × ×•×›×—×™×ª ×•×›×•'.
    """

    def __init__(self):
        """
        ××ª×—×•×œ ×›×œ ×”× ×ª×•× ×™× ×”×”×›×¨×—×™×™× ×œ××¤×œ×™×§×¦×™×”.
        """
        # ×¤×¨×˜×™ ××¡×“ ×”× ×ª×•× ×™×
        self.db_host = "127.0.0.1"
        self.db_user = "root"
        self.db_password = "Speedman1978"
        self.db_name = "python_project"

        # ××¦×‘ ×”××©×—×§ (Game State)
        self.player_name = ""               # ×©× ×”×©×—×§×Ÿ
        self.selected_category = None       # ×§×˜×’×•×¨×™×” ×©× ×‘×—×¨×” ×›×¨×’×¢
        self.score = 0                      # × ×™×§×•×“ ×”×©×—×§×Ÿ
        self.questions_answered = 0         # ×›××” ×©××œ×•×ª × ×¢× ×• ×¢×“ ×›×”
        self.categories_completed = 0       # ××¡×¤×¨ ×§×˜×’×•×¨×™×•×ª ×©×”×•×©×œ××•
        self.game_over = False              # ×”×× ×”××©×—×§ ×”×¡×ª×™×™×
        self.date_played = None             # ×ª××¨×™×š/×–××Ÿ ×‘×• ×”×©×—×§×Ÿ ×¡×™×™× ××©×—×§
        self.used_categories = []           # ×§×˜×’×•×¨×™×•×ª ×©×›×‘×¨ × ×‘×—×¨×• ×‘××”×œ×š ×”××©×—×§
        self.current_category_questions = 0 # ×›××” ×©××œ×•×ª × ×¢× ×• ×‘×§×˜×’×•×¨×™×” × ×•×›×—×™×ª
        self.show_category_completed = False# ×”×× ×œ×”×¦×™×’ ××¡×š ×§×˜×’×•×¨×™×” ×”×•×©×œ××”
        self.category_completion_timer = 0  # ×˜×™×™××¨ ×¤× ×™××™ ×œ×©×”×™×™×” ×¢×œ ××¡×š Completion
        self.waiting_for_feedback = False   # ×”×× ××—×›×™× ×œ×¡×™×•× ×”×¦×’×ª ×”×¤×™×“×‘×§ ×œ××—×¨ ×ª×©×•×‘×”

        # × ×ª×•× ×™× ×”×§×©×•×¨×™× ×œ×©××œ×•×ª ×•Ö¾API
        self.GROQ_API_KEY = "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"
        self.seen_questions = set()         # ××•×¡×£ ×©××œ×•×ª ×©×›×‘×¨ ×”×•×¤×™×¢×•, ×œ×× ×™×¢×ª ×›×¤×™×œ×•×™×•×ª
        self.failed_categories = set()      # ××•×¡×£ ×§×˜×’×•×¨×™×•×ª ×©×›×©×œ× ×• ×œ×”×‘×™× ×‘×”×Ÿ ×©××œ×•×ª
        self.question_cache = {}            # ××˜××•×Ÿ ×©××œ×•×ª ×œ×›×œ ×§×˜×’×•×¨×™×”
        self.current_question = None        # ×”×©××œ×” ×”× ×•×›×—×™×ª (tuple: (×©××œ×”, ××•×¤×¦×™×•×ª, ×ª×©×•×‘×”-× ×›×•× ×”))

        # ×”×’×“×¨×•×ª ××©×—×§
        self.questions_per_category = 5     # ××¡×¤×¨ ×©××œ×•×ª ×œ×›×œ ×§×˜×’×•×¨×™×”
        self.total_categories_to_play = 6   # ×¡×š ××¡×¤×¨ ×”×§×˜×’×•×¨×™×•×ª ×œ×©×—×§
        self.total_questions = (self.questions_per_category *
                                self.total_categories_to_play)  # 30 (×‘×¨×™×¨×ª ××—×“×œ)

        # ×¤×™×“×‘×§ ×¢×œ ×ª×©×•×‘×•×ª × ×›×•× ×•×ª/×©×’×•×™×•×ª
        self.feedback_message = None        # ×˜×§×¡×˜ ×”×¤×™×“×‘×§ (× ×›×•×Ÿ/×œ× × ×›×•×Ÿ)
        self.feedback_timer = 0             # ×˜×™×™××¨ ×œ×”×¦×’×ª ×”×¤×™×“×‘×§

        # ×¦×œ×™×œ×™× (×™×˜×¢× ×• ×œ××—×¨-××›×Ÿ ××‘×—×•×¥)
        self.correct_sound = None
        self.incorrect_sound = None

        # ××ª×—×•×œ ×•×—×™×‘×•×¨ ×œ××¡×“ ×”× ×ª×•× ×™×
        self.initialize_database()

    def initialize_database(self):
        """
        ××•×•×“× ×©×”×˜×‘×œ×” scores ×§×™×™××ª ×‘××¡×“ ×”× ×ª×•× ×™×. ×× ×œ×, ×™×•×¦×¨×ª ××•×ª×”.
        """
        try:
            conn = mysql.connector.connect(
                host=self.db_host,
                user=self.db_user,
                password=self.db_password,
                database=self.db_name
            )
            cursor = conn.cursor()

            # ×™×¦×™×¨×ª ×”×˜×‘×œ×” ×× ×”×™× ×œ× ×§×™×™××ª
            cursor.execute('''
            CREATE TABLE IF NOT EXISTS scores (
                id INT AUTO_INCREMENT PRIMARY KEY,
                player_name VARCHAR(255) NOT NULL,
                score INT NOT NULL,
                category VARCHAR(255) NOT NULL,
                date_played DATETIME NOT NULL
            )
            ''')
            conn.commit()
            conn.close()
            print("âœ… Database initialized successfully")

        except mysql.connector.Error as e:
            print(f"âŒ Error initializing database: {e}")
            sys.exit(1)  # ×× ×œ× ××¦×œ×™×—×™× ×œ×”×ª×—×‘×¨/×œ×™×¦×•×¨ ×˜×‘×œ×” â€“ ×¡×™×™× ××ª ×”×ª×•×›× ×™×ª

    def save_score(self, player_name, score, category):
        """
        ×©××™×¨×ª × ×™×§×•×“ ×‘××¡×“ ×”× ×ª×•× ×™× ×ª×—×ª ×”×©× ×•×”×§×˜×’×•×¨×™×” ×”××‘×•×§×©×ª.
        ××—×–×™×¨ ××ª ×”×ª××¨×™×š ×•×”×©×¢×” ×‘×” × ×©××¨ ×”× ×™×§×•×“.
        """
        date_played = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        try:
            conn = mysql.connector.connect(
                host=self.db_host,
                user=self.db_user,
                password=self.db_password,
                database=self.db_name
            )
            cursor = conn.cursor()

            cursor.execute(
                "INSERT INTO scores (player_name, score, category, date_played) VALUES (%s, %s, %s, %s)",
                (player_name, score, category, date_played)
            )
            conn.commit()
            conn.close()
            print(f"âœ… Score saved: {player_name}, {score}, {category}, {date_played}")
        except mysql.connector.Error as e:
            print(f"âŒ Error saving score: {e}")

        return date_played

    def fetch_question_from_ai(self, category, difficulty):
        """
        ×©×œ×™×¤×ª ×©××œ×” ××”Ö¾API (Groq) ×‘×”×ª×× ×œ×§×˜×’×•×¨×™×” ×•×¨××ª ×”×§×•×©×™.
        ××—×–×™×¨ tuple (question, options, answer) ××• (None, None, None) ×‘××§×¨×” ×©×œ ×›×™×©×œ×•×Ÿ.
        """
        url = "https://api.groq.com/openai/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.GROQ_API_KEY}",
            "Content-Type": "application/json"
        }

        # ×”×”× ×—×™×” ×œ×× ×•×¢ ×”×‘×™× ×” ×”××œ××›×•×ª×™×ª
        prompt = (
            f"Generate a {difficulty} multiple-choice trivia question about {category}. "
            "The question should be different from any you've generated before. "
            "Strictly return only a JSON object like this: "
            '{"question": "What is the capital of France?", "options": ["Berlin", "Madrid", "Paris", "Lisbon"], "answer": "Paris"}'
        )

        data = {
            "model": "llama3-8b-8192",  # ×”××•×“×œ ×‘Ö¾Groq API
            "messages": [{"role": "user", "content": prompt}],
            "max_tokens": 300
        }

        try:
            response = requests.post(url, headers=headers, json=data)
            response_json = response.json()

            # ×‘×•×“×§×™× ×× ×§×™×‘×œ× ×• ×ª×©×•×‘×” (choices)
            if "choices" in response_json and len(response_json["choices"]) > 0:
                ai_output = response_json["choices"][0]["message"]["content"]

                # ××•×¦××™× ×’×•×© JSON ××ª×•×š ×”×˜×§×¡×˜
                json_match = re.search(r'\{.*\}', ai_output, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                else:
                    return None, None, None

                try:
                    data = json.loads(json_str)
                    question_text = data["question"].strip()
                    options = data["options"]
                    answer = data["answer"]

                    # ×•×™×“×•× ×©×”×ª×©×•×‘×” ×§×™×™××ª ×‘××•×¤×¦×™×•×ª
                    if answer not in options:
                        print(f"âš ï¸ Answer '{answer}' not in options. Fixing...")
                        if len(options) > 0:
                            options[-1] = answer
                        else:
                            options = [answer, "Option 2", "Option 3", "Option 4"]

                    # ×‘×“×™×§×” ×©×œ× ×©××œ× ×• ××ª ×”×©××œ×” ×”×–×• ×§×•×“×
                    if question_text.lower() in self.seen_questions:
                        return None, None, None

                    self.seen_questions.add(question_text.lower())
                    return question_text, options, answer

                except (json.JSONDecodeError, KeyError) as e:
                    print(f"âŒ Error parsing question JSON: {e}")
                    return None, None, None
        except Exception as e:
            print(f"âŒ Error fetching question from AI: {e}")

        return None, None, None

    def preload_questions_thread(self):
        """
        Thread ×œ×˜×¢×™× ×” ××•×§×“××ª ×©×œ ×©××œ×•×ª ×œ×›×œ ×§×˜×’×•×¨×™×”.
        ×›×š ×”××©×ª××© ×œ× ×™×¦×˜×¨×š ×œ×—×›×•×ª ×‘×–××Ÿ ×”××©×—×§.
        """
        categories = ["History", "Computer Science", "Science", "Geography", "Movies", "Sports"]
        print("ğŸ”„ Preloading questions in background...")

        # ×¢×‘×•×¨ ×›×œ ×§×˜×’×•×¨×™×”
        for category in categories:
            if category not in self.question_cache:
                self.question_cache[category] = []

            # × ××©×™×š ×œ×˜×¢×•×Ÿ ×©××œ×•×ª ×¢×“ ×©× ×’×™×¢ ×œ××¡×¤×¨ ×”×¨×¦×•×™
            while len(self.question_cache[category]) < self.questions_per_category:
                q, opts, ans = self.fetch_question_from_ai(category, "medium")
                if q is not None:
                    self.question_cache[category].append((q, opts, ans))
                    print(f"âœ… Preloaded question for {category} "
                          f"({len(self.question_cache[category])}/{self.questions_per_category})")
                else:
                    # ×× × ×›×©×œ× ×• ×¤×¢××™×™× ×‘××•×ª×” ×§×˜×’×•×¨×™×”, × ×¤×¡×™×§
                    if category in self.failed_categories:
                        print(f"âŒ Failed to preload questions for {category}. Skipping.")
                        break
                    self.failed_categories.add(category)

    def reset_game(self):
        """
        ××™×¤×•×¡ ××•×—×œ×˜ ×©×œ ××¦×‘ ×”××©×—×§ ×œ×¦×•×¨×š ××©×—×§ ×—×“×©.
        """
        self.selected_category = None
        self.score = 0
        self.current_question = None
        self.questions_answered = 0
        self.categories_completed = 0
        self.game_over = False
        self.date_played = None
        self.feedback_message = None
        self.feedback_timer = 0
        self.used_categories = []
        self.seen_questions.clear()
        self.current_category_questions = 0
        self.show_category_completed = False
        self.category_completion_timer = 0
        self.waiting_for_feedback = False
        self.failed_categories = set()
        self.question_cache = {}

    def is_category_available(self, category):
        """
        ×‘×•×“×§ ×”×× ×§×˜×’×•×¨×™×” ×›×‘×¨ ×©×•×—×§×”/× ×‘×—×¨×” ×‘×¢×‘×¨ ××• ×œ×.
        ×× ×›×‘×¨ ×©×•×—×§×”, ×œ× × ×™×ª×Ÿ ×œ×‘×—×•×¨ ××•×ª×” ×©×•×‘.
        """
        return category not in self.used_categories


class TriviaView:
    """
    ××—×œ×§×” ×–×• (View) ××—×¨××™×ª ×¢×œ ×›×œ ××” ×©×§×©×•×¨ ×œ×”×¦×’×” ×•×¦×™×•×¨ ×‘×××¦×¢×•×ª Pygame:
    - ×¦×™×•×¨ ×¨×§×¢×™×, ×˜×§×¡×˜, ×›×¤×ª×•×¨×™×, ×ª×™×‘×•×ª ×©××œ×” ×•×¢×•×“.
    - ××™×Ÿ ×‘×” ×œ×•×’×™×§×ª ××©×—×§ ××• ×¢×¡×§×™×ª, ×¨×§ ×§×•×“ ×©××¦×™×™×¨ ××¡×›×™× ×‘×”×ª×‘×¡×¡ ×¢×œ ××¦×‘ × ×ª×•×Ÿ.
    """

    def __init__(self, width=1000, height=700):
        # ×”×’×“×¨×•×ª ×—×œ×•×Ÿ
        self.WIDTH = width
        self.HEIGHT = height
        self.screen = pygame.display.set_mode((self.WIDTH, self.HEIGHT))
        pygame.display.set_caption("Trivia Game - AI Generated Questions")

        # ×¦×‘×¢×™× ×œ×©×™××•×©
        self.WHITE = (255, 255, 255)
        self.BLACK = (0, 0, 0)
        self.BLUE = (70, 130, 180)
        self.GREEN = (34, 139, 34)
        self.RED = (220, 20, 60)
        self.LIGHT_GRAY = (240, 240, 240)
        self.YELLOW = (255, 215, 0)
        self.PURPLE = (147, 112, 219)
        self.HIGHLIGHT_COLOR = (200, 220, 255)
        self.DISABLED_COLOR = (200, 200, 200)
        self.DISABLED_TEXT = (150, 150, 150)

        # ×¤×•× ×˜×™×
        self.font = pygame.font.Font(None, 40)
        self.large_font = pygame.font.Font(None, 60)
        self.small_font = pygame.font.Font(None, 30)

    def draw_gradient_background(self):
        """
        ×¦×™×•×¨ ×¨×§×¢ ×’×¨××“×™×× ×˜×™ ×× ×›×™ ×‘×™×Ÿ YELLOW ×œÖ¾PURPLE.
        """
        for y in range(self.HEIGHT):
            r = int(self.YELLOW[0] + (self.PURPLE[0] - self.YELLOW[0]) * y / self.HEIGHT)
            g = int(self.YELLOW[1] + (self.PURPLE[1] - self.YELLOW[1]) * y / self.HEIGHT)
            b = int(self.YELLOW[2] + (self.PURPLE[2] - self.YELLOW[2]) * y / self.HEIGHT)
            pygame.draw.line(self.screen, (r, g, b), (0, y), (self.WIDTH, y))

    def draw_text(self, text, x, y, font_obj, color=(0, 0, 0)):
        """
        ×¦×™×•×¨ ×˜×§×¡×˜ ×¨×’×™×œ ×¢×œ ×”××¡×š ×‘× ×§×•×“×” (x,y).
        """
        text_surface = font_obj.render(text, True, color)
        self.screen.blit(text_surface, (x, y))

    def draw_text_centered(self, text, x, y, font_obj, color=(0, 0, 0)):
        """
        ×¦×™×•×¨ ×˜×§×¡×˜ ×××•×¨×›×– ×¢×œ ×”××¡×š, ×›××©×¨ (x,y) ×”×•× ××¨×›×– ×”×˜×§×¡×˜.
        """
        text_surface = font_obj.render(text, True, color)
        text_rect = text_surface.get_rect(center=(x, y))
        self.screen.blit(text_surface, text_rect)

    def wrap_text(self, text, font_obj, max_width):
        """
        ×¢×•×˜×£ ×˜×§×¡×˜ ×›×š ×©×œ× ×™×¢×‘×•×¨ ×¨×•×—×‘ ××§×¡×™××œ×™ ××¡×•×™× (max_width).
        ××—×–×™×¨ ×¨×©×™××ª ×©×•×¨×•×ª.
        """
        words = text.split(" ")
        lines = []
        current_line = ""
        for word in words:
            test_line = current_line + word + " "
            if font_obj.size(test_line)[0] < max_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        if current_line:
            lines.append(current_line)
        return lines

    def draw_question(self, question_data, mouse_pos):
        """
        ××¦×™×’ ××ª ×”×©××œ×” ×•×”××¤×©×¨×•×™×•×ª. ××•×¡×™×£ ××¤×§×˜ ×¨×™×—×•×£ ×¢×œ ×”××•×¤×¦×™×•×ª ×œ×¤×™ ××™×§×•× ×”×¢×›×‘×¨.
        """
        if question_data is None or question_data[0] is None:
            self.draw_text_centered(
                "âŒ Error: No question available",
                self.WIDTH // 2, self.HEIGHT // 2,
                self.large_font, self.RED
            )
            return

        question_text, options, _ = question_data
        wrapped_text = self.wrap_text(question_text, self.font, self.WIDTH - 100)

        # ×¦×™×•×¨ ×ª×™×‘×ª ×”×©××œ×” + ×¦×œ (shadow)
        question_box_height = len(wrapped_text) * 45 + 20
        pygame.draw.rect(self.screen, (0, 0, 0, 50),
                         (48, 98, self.WIDTH - 96, question_box_height),
                         border_radius=10)
        pygame.draw.rect(self.screen, self.WHITE,
                         (45, 95, self.WIDTH - 90, question_box_height),
                         border_radius=10)

        # ×¦×™×•×¨ ×”×˜×§×¡×˜ ×©×œ ×”×©××œ×”
        y_offset = 105
        for line in wrapped_text:
            self.draw_text(line, 60, y_offset, self.font, self.BLUE)
            y_offset += 45

        # ×¦×™×•×¨ ×”×ª×©×•×‘×•×ª (××•×¤×¦×™×•×ª)
        answer_y = y_offset + 30
        for i, option in enumerate(options):
            option_rect = pygame.Rect(40, answer_y - 10, self.WIDTH - 80, 50)
            # ×‘×“×™×§×” ×× ×”×¢×›×‘×¨ ××¨×—×£ ××¢×œ
            if option_rect.collidepoint(mouse_pos):
                pygame.draw.rect(self.screen, self.HIGHLIGHT_COLOR, option_rect, border_radius=5)
            else:
                pygame.draw.rect(self.screen, self.LIGHT_GRAY, option_rect, border_radius=5)

            self.draw_text(f"{chr(65 + i)}. {option}", 60, answer_y, self.font)
            answer_y += 70

    def draw_feedback(self, feedback_message, feedback_timer):
        """
        ××¦×™×’ ×¤×™×“×‘×§ (Correct / Incorrect) ×œ×–××Ÿ ×§×¦×¨ ×¢×œ ×”××¡×š.
        """
        if feedback_message:
            color = self.GREEN if "Correct" in feedback_message else self.RED
            # ×¨×§×¢ ×—×¦×™-×©×§×•×£ ×œ×”×¦×’×ª ×”×¤×™×“×‘×§
            s = pygame.Surface((self.WIDTH - 100, 130), pygame.SRCALPHA)
            s.fill((255, 255, 255, 220))
            self.screen.blit(s, (50, self.HEIGHT // 2 - 65))

            # ×× ×”×”×•×“×¢×” ××¨×•×›×”, × ×©×ª××© ×‘×¤×•× ×˜×™× ×§×˜× ×™× ×™×•×ª×¨
            if len(feedback_message) > 40:
                lines = self.wrap_text(feedback_message, self.small_font, self.WIDTH - 150)
                y_offset = self.HEIGHT // 2 - 40
                for line in lines:
                    self.draw_text_centered(line, self.WIDTH // 2, y_offset, self.small_font, color)
                    y_offset += 30
            else:
                self.draw_text_centered(feedback_message, self.WIDTH // 2, self.HEIGHT // 2,
                                        self.font, color)

    def draw_category_completed(self, model):
        """
        ××¡×š ×‘×™× ×™×™× ×›××©×¨ ×”×©×—×§×Ÿ ×¡×™×™× ××ª ×›×œ ×”×©××œ×•×ª ×‘×§×˜×’×•×¨×™×” ××¡×•×™××ª.
        ××¦×™×’ ×¡×™×›×•× ×‘×™× ×™×™× ×•× ×•×ª×Ÿ ×›×¤×ª×•×¨ ×œ×‘×—×•×¨ ×§×˜×’×•×¨×™×” ×—×“×©×”.
        """
        self.draw_gradient_background()

        # ×›×•×ª×¨×ª ×¢× ×¦×œ
        pygame.draw.rect(self.screen, (0, 0, 0, 50),
                         (self.WIDTH // 2 - 230, 98, 460, 60),
                         border_radius=10)
        pygame.draw.rect(self.screen, self.WHITE,
                         (self.WIDTH // 2 - 225, 95, 450, 60),
                         border_radius=10)
        self.draw_text_centered("Category Completed!",
                                self.WIDTH // 2, 125,
                                self.large_font, self.BLUE)

        # ×ª×™×‘×ª ×¡×˜×˜×™×¡×˜×™×§×”
        stats_box = pygame.Rect(self.WIDTH // 2 - 250, 180, 500, 220)
        pygame.draw.rect(self.screen, (0, 0, 0, 50), stats_box.inflate(6, 6), border_radius=15)
        pygame.draw.rect(self.screen, self.WHITE, stats_box, border_radius=15)

        # ×”×¦×’×ª ×¤×¨×˜×™ ×‘×™× ×™×™×
        self.draw_text_centered(f"Player: {model.player_name}", self.WIDTH // 2, 220, self.font, self.BLACK)
        self.draw_text_centered(f"Current Score: {model.score}/{model.total_questions}",
                                self.WIDTH // 2, 270, self.font, self.GREEN)
        self.draw_text_centered(f"Categories Completed: {model.categories_completed}/{model.total_categories_to_play}",
                                self.WIDTH // 2, 320, self.font, self.BLUE)
        questions_left = model.total_questions - model.questions_answered
        self.draw_text_centered(f"Questions Left: {questions_left}",
                                self.WIDTH // 2, 370, self.font, self.BLACK)

        # ×›×¤×ª×•×¨ ×”××©×š ×œ×§×˜×’×•×¨×™×” ×”×‘××”
        button_rect = pygame.Rect(self.WIDTH // 2 - 180, 450, 360, 70)

        # ×¨×§ ××—×¨×™ ×©×”×˜×™×™××¨ ××¡×ª×™×™×, × ×¦×™×’ ××ª ×”×›×¤×ª×•×¨ ×œ×¤×¢×•×œ×”
        if model.category_completion_timer <= 0:
            pygame.draw.rect(self.screen, (0, 0, 0, 50), button_rect.inflate(6, 6), border_radius=10)
            pygame.draw.rect(self.screen, self.LIGHT_GRAY, button_rect, border_radius=10)

            mouse_pos = pygame.mouse.get_pos()
            if button_rect.collidepoint(mouse_pos):
                pygame.draw.rect(self.screen, self.HIGHLIGHT_COLOR, button_rect, border_radius=10)

            self.draw_text_centered("Choose Next Category", self.WIDTH // 2, 485, self.font, self.BLUE)
        else:
            # ××¦×™×’×™× ×˜×™×™××¨ ×©×¢×œ×™×• ×¦×¨×™×š ×œ×—×›×•×ª
            model.category_completion_timer -= 1
            self.draw_text_centered(f"Next in {model.category_completion_timer // 30 + 1}...",
                                    self.WIDTH // 2, 485, self.font, self.BLUE)

    def draw_game_over(self, model):
        """
        ××¡×š ×¡×™×•× ×”××©×—×§. ××¦×™×’ × ×™×§×•×“ ×¡×•×¤×™, ××—×•×–×™ ×”×¦×œ×—×”, ×ª××¨×™×š ×•×¢×•×“.
        ×›×•×œ×œ ×›×¤×ª×•×¨×™×: ×©×—×§ ×©×•×‘ (Play Again) ××• ×¦× (Quit).
        """
        self.draw_gradient_background()

        # ×¦×™×•×¨ ×’×‘×™×¢ (×¨×§ ×œ×¦×•×¨×š ×§×™×©×•×˜)
        pygame.draw.polygon(self.screen, self.YELLOW, [
            (self.WIDTH // 2, 50),
            (self.WIDTH // 2 - 60, 70),
            (self.WIDTH // 2 - 30, 120),
            (self.WIDTH // 2 + 30, 120),
            (self.WIDTH // 2 + 60, 70)
        ])
        pygame.draw.rect(self.screen, self.YELLOW, (self.WIDTH // 2 - 20, 120, 40, 30))
        pygame.draw.rect(self.screen, self.YELLOW, (self.WIDTH // 2 - 40, 150, 80, 10))

        # ×›×•×ª×¨×ª
        self.draw_text_centered("Game Completed!", self.WIDTH // 2, 200, self.large_font, self.BLUE)

        # ×ª×™×‘×ª ×¡×˜×˜×™×¡×˜×™×§×”
        stats_box = pygame.Rect(self.WIDTH // 2 - 200, 250, 400, 180)
        pygame.draw.rect(self.screen, (0, 0, 0, 50), stats_box.inflate(6, 6), border_radius=15)
        pygame.draw.rect(self.screen, self.WHITE, stats_box, border_radius=15)

        # ×”×¦×’×ª ×¤×¨×˜×™×
        self.draw_text_centered(f"Player: {model.player_name}", self.WIDTH // 2, 280, self.font, self.BLACK)
        self.draw_text_centered(f"Final Score: {model.score}/{model.total_questions}",
                                self.WIDTH // 2, 320, self.font, self.BLACK)
        percentage = (model.score / model.total_questions) * 100

        # ×¦×‘×™×¢×ª ×”××—×•×– ×‘×”×ª×× ×œ×¨××ª ×”×‘×™×¦×•×¢
        percentage_color = self.RED
        if percentage >= 80:
            percentage_color = self.GREEN
        elif percentage >= 60:
            percentage_color = self.BLUE

        self.draw_text_centered(f"Percentage: {percentage:.1f}%", self.WIDTH // 2, 360, self.font, percentage_color)

        # ×ª××¨×™×š
        if not model.date_played:
            model.date_played = datetime.now().strftime("%d/%m/%Y %H:%M")
        self.draw_text_centered(f"Date: {model.date_played}", self.WIDTH // 2, 400, self.font, self.BLACK)

        # ×›×¤×ª×•×¨ "Play Again"
        play_again_rect = pygame.Rect(self.WIDTH // 2 - 150, 450, 300, 60)
        mouse_pos = pygame.mouse.get_pos()

        # ×¦×œ + ×›×¤×ª×•×¨
        pygame.draw.rect(self.screen, (0, 0, 0, 50), play_again_rect.inflate(6, 6), border_radius=10)
        if play_again_rect.collidepoint(mouse_pos):
            pygame.draw.rect(self.screen, self.HIGHLIGHT_COLOR, play_again_rect, border_radius=10)
        else:
            pygame.draw.rect(self.screen, self.LIGHT_GRAY, play_again_rect, border_radius=10)
        self.draw_text_centered("Play Again", self.WIDTH // 2, 480, self.font, self.BLUE)

        # ×›×¤×ª×•×¨ "Quit"
        quit_rect = pygame.Rect(self.WIDTH // 2 - 150, 530, 300, 60)
        pygame.draw.rect(self.screen, (0, 0, 0, 50), quit_rect.inflate(6, 6), border_radius=10)
        if quit_rect.collidepoint(mouse_pos):
            pygame.draw.rect(self.screen, self.HIGHLIGHT_COLOR, quit_rect, border_radius=10)
        else:
            pygame.draw.rect(self.screen, self.LIGHT_GRAY, quit_rect, border_radius=10)
        self.draw_text_centered("Quit Game", self.WIDTH // 2, 560, self.font, self.RED)

    def draw_loading(self, model):
        """
        ××¡×š ×˜×¢×™× ×”. ××¦×™×’ ×× ×™××¦×™×™×ª "×“×•×¤×§" (pulse) ×•×¡×˜×˜×•×¡ ×˜×¢×™× ×ª ×”×©××œ×•×ª.
        """
        # ×¢×¨×š ×‘×™×Ÿ 0 ×œ-1 (××•×“ 1000 ××™×œ×™×©× ×™×•×ª)
        pulse = (pygame.time.get_ticks() % 1000) / 1000
        radius = 30 + int(10 * pulse)  # ×¨×“×™×•×¡ ××©× ×” ×’×•×“×œ ×‘×™×Ÿ 30 ×œ-40

        pygame.draw.circle(self.screen, self.BLUE, (self.WIDTH // 2, self.HEIGHT // 2 - 50), radius)
        pygame.draw.circle(self.screen, self.WHITE, (self.WIDTH // 2, self.HEIGHT // 2 - 50), radius - 5)

        self.draw_text_centered("Loading question...", self.WIDTH // 2, self.HEIGHT // 2 + 20,
                                self.large_font, self.BLUE)
        self.draw_text_centered(f"Category: {model.selected_category}",
                                self.WIDTH // 2, self.HEIGHT // 2 + 80,
                                self.font)

        # ××¦×™×’×™× ×’× ×”×ª×§×“××•×ª
        display_question_num = model.current_category_questions if model.current_category_questions > 0 else 1
        self.draw_text_centered(f"Question {display_question_num}/{model.questions_per_category}",
                                self.WIDTH // 2, self.HEIGHT // 2 + 120,
                                self.font)
        self.draw_text_centered(f"Total Progress: {model.questions_answered}/{model.total_questions}",
                                self.WIDTH // 2, self.HEIGHT // 2 + 160,
                                self.font)


class TriviaController:
    """
    ××—×œ×§×” ×–×• (Controller) ×× ×”×œ×ª ××ª ×”×–×¨×™××” ×©×œ ×”××©×—×§:
    - ×§×œ×™×˜×ª ××™×¨×•×¢×™× (×¢×›×‘×¨, ××§×œ×“×ª).
    - ×¢×“×›×•×Ÿ ×”Ö¾Model (××¦×‘ ×”××©×—×§) ×‘×”×ª×× ×œ××™×¨×•×¢×™×.
    - ×§×¨×™××” ×œÖ¾View ×œ×¦×™×•×¨ ×”×ª×¦×•×’×” ×”××ª××™××”.
    - × ×™×”×•×œ ×”×œ×•×œ××” ×”×¨××©×™×ª ×©×œ ×”××©×—×§.
    """

    def __init__(self, model, view):
        self.model = model
        self.view = view
        self.running = True
        self.clock = pygame.time.Clock()
        self.loading = False  # ×”×× ×× ×—× ×• ×‘××¦×‘ "×˜×•×¢× ×™× ×©××œ×”" ×›×¢×ª

        # ×˜×•×¢× ×™× ×¦×œ×™×œ×™× ×•××•×–×™×§×ª ×¨×§×¢ (×œ× ×—×œ×§ ××”Ö¾Model, ×›×“×™ ×©×”×§×¦×‘×™× ×™×—×™×• ×‘Ö¾Controller / ×”Ö¾View)
        self.load_audio()

        # ×¤×ª×™×—×ª Thread ×œ×˜×¢×™× ×” ××•×§×“××ª ×©×œ ×©××œ×•×ª
        preload_thread = threading.Thread(target=self.model.preload_questions_thread)
        preload_thread.daemon = True
        preload_thread.start()

    def load_audio(self):
        """
        ×˜×•×¢×Ÿ ×§×‘×¦×™ ××•×“×™×• ×•××•×–×™×§×ª ×¨×§×¢, ×•×©×•××¨ ××•×ª× ×‘Ö¾Model (correct_sound, incorrect_sound).
        """
        try:
            # ××•×–×™×§×ª ×¨×§×¢
            pygame.mixer.music.load("chill-drum-loop-6887.mp3")

            # ×¦×œ×™×œ×™× ×©×œ × ×›×•×Ÿ/×œ× × ×›×•×Ÿ
            self.model.correct_sound = pygame.mixer.Sound("ding-small-bell-sfx-233008.mp3")
            self.model.incorrect_sound = pygame.mixer.Sound("incorrect-293358.mp3")

        except pygame.error as e:
            print(f"Error loading audio files: {e}. Please ensure the files are in the working directory: {os.getcwd()}")
            sys.exit(1)

        # ×”×¤×¢×œ×ª ×”××•×–×™×§×”
        pygame.mixer.music.play(-1)
        pygame.mixer.music.set_volume(0.3)

    def get_player_name(self):
        """
        ××¡×š ×ª×—×™×œ×™ ×©×‘×• ××‘×§×©×™× ××”××©×ª××© ×œ×”×–×™×Ÿ ××ª ×©××• ×œ×¤× ×™ ×”×ª×—×œ×ª ×”××©×—×§.
        ××—×–×™×¨ ××ª ×”×©× ×©×”×•×–×Ÿ.
        """
        input_box_rect = pygame.Rect(self.view.WIDTH // 2 - 200, self.view.HEIGHT // 2, 400, 60)
        player_name = ""
        active = True
        font = pygame.font.Font(None, 40)

        while active:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_RETURN and player_name.strip():
                        print(f"âœ… Player entered name: {player_name}")
                        return player_name.strip()
                    elif event.key == pygame.K_BACKSPACE:
                        player_name = player_name[:-1]
                    else:
                        player_name += event.unicode

            self.view.draw_gradient_background()
            self.view.draw_text_centered("Enter your name:",
                                         self.view.WIDTH // 2,
                                         self.view.HEIGHT // 2 - 50,
                                         self.view.large_font,
                                         self.view.BLUE)

            # ×ª×™×‘×ª ×˜×§×¡×˜ ×‘×” ×”×©×—×§×Ÿ ××§×œ×™×“ ××ª ×©××•
            pygame.draw.rect(self.view.screen, self.view.LIGHT_GRAY, input_box_rect, border_radius=5)
            text_surface = font.render(player_name, True, self.view.BLACK)
            self.view.screen.blit(text_surface, (input_box_rect.x + 10, input_box_rect.y + 10))

            pygame.display.flip()
            pygame.time.Clock().tick(30)

    def generate_next_question(self):
        """
        ××™×™×¦×¨ ×©××œ×” ×—×“×©×” ×‘-Thread ×¨×§×¢ ×›×“×™ ×œ× ×œ×—×¡×•× ××ª ×”×œ×•×œ××” ×”×¨××©×™×ª.
        ××¢×“×›×Ÿ ××ª ×”Ö¾Model ×‘×©××œ×” ×”×—×“×©×” (××• ×‘××¦×‘ "×¡×™×™×× ×• ×§×˜×’×•×¨×™×”" / "×¡×™×™×× ×• ××©×—×§").
        """
        def target():
            # ×× ×–×• ×”×©××œ×” ×”×¨××©×•× ×” ×‘×§×˜×’×•×¨×™×” ×”× ×•×›×—×™×ª
            if self.model.current_category_questions == 0:
                self.model.current_category_questions = 1
            elif self.model.current_category_questions < self.model.questions_per_category:
                self.model.current_category_questions += 1

            # ××’×“×™×œ×™× ××•× ×” ×›×œ×œ×™ ×©×œ ×©××œ×•×ª ×©× ×¢× ×•
            self.model.questions_answered += 1

            # ×‘×“×™×§×” ×× ×¡×™×™×× ×• ××ª ×”×§×˜×’×•×¨×™×” (×”×’×¢× ×• ×œ××¡×¤×¨ ×©××œ×•×ª ×”×“×¨×•×© ×‘×§×˜×’×•×¨×™×”)
            if self.model.current_category_questions >= self.model.questions_per_category:
                self.model.categories_completed += 1
                self.model.used_categories.append(self.model.selected_category)
                self.model.current_category_questions = 0

                # ×‘×“×™×§×” ×× ×¡×™×™×× ×• ××ª ×›×œ ×”×§×˜×’×•×¨×™×•×ª
                if self.model.categories_completed >= self.model.total_categories_to_play:
                    self.loading = False
                    self.model.game_over = True
                    # ×©××™×¨×ª ×¦×™×•×Ÿ "×›×œ×œ×™" â€“ ×›×™ ×©×™×—×§× ×• ×‘××¡×¤×¨ ×§×˜×’×•×¨×™×•×ª
                    self.model.date_played = self.model.save_score(
                        self.model.player_name,
                        self.model.score,
                        "Multiple Categories"
                    )
                    return
                else:
                    # ×× ×¢×•×“ ×œ× ×¡×™×™×× ×• ××ª ×”××©×—×§, ××¦×™×’×™× "×§×˜×’×•×¨×™×” ×”×•×©×œ××”" ××œ× ×× ××—×›×™× ×œ×¤×™×“×‘×§
                    if not self.model.waiting_for_feedback:
                        self.loading = False
                        self.model.show_category_completed = True
                        self.model.category_completion_timer = 90  # ×œ××©×œ, 3 ×©× ×™×•×ª (30 FPS)
                        return

            # × ×™×¡×™×•×Ÿ ×œ×”×©×ª××© ×‘×©××œ×•×ª ×©×”×’×™×¢×• ×‘×˜×¢×™× ×” ×”××•×§×“××ª (cache)
            if (self.model.selected_category in self.model.question_cache and
                    self.model.question_cache[self.model.selected_category]):
                self.model.current_question = self.model.question_cache[self.model.selected_category].pop(0)
                self.loading = False
                return

            # ×× ××™×Ÿ ×‘××˜××•×Ÿ, × × ×¡×” ×œ×™×¦×•×¨ ×©××œ×” ××”Ö¾API
            max_attempts = 10
            attempts = 0
            result = (None, None, None)
            print(f"ğŸ”„ Generating question {self.model.questions_answered} "
                  f"(Category: {self.model.selected_category})...")

            while attempts < max_attempts:
                result = self.model.fetch_question_from_ai(self.model.selected_category, "medium")
                if result[0] is not None:
                    break
                attempts += 1
                print(f"âš ï¸ Attempt {attempts}/{max_attempts} failed for {self.model.selected_category}")

            # ×× × ×›×©×œ× ×• ×œ×’××¨×™ â€“ × ×™×¦×•×¨ ×©××œ×” ×‘×¡×™×¡×™×ª fallback
            if result[0] is None:
                print(f"âŒ Failed to generate question for {self.model.selected_category} after {max_attempts} attempts")
                question = f"What category is this question from?"
                options = ["History", "Science", "Geography", self.model.selected_category]
                answer = self.model.selected_category
                result = (question, options, answer)

            # ×©××™×¨×ª ×”×©××œ×”
            self.model.current_question = result
            self.loading = False

        self.loading = True
        thread = threading.Thread(target=target)
        thread.daemon = True
        thread.start()

    def run(self):
        """
        ×œ×•×œ××ª ×”××©×—×§ ×”×¨××©×™×ª â€“ ×× ×”×œ×ª ××ª ×”×–×¨×™××” ×©×œ ×”××©×—×§ (events, updates, drawing).
        """
        # ×‘×ª×—×™×œ×ª ×”××©×—×§, ××‘×§×©×™× ×©× ×©×—×§×Ÿ
        self.model.player_name = self.get_player_name()

        while self.running:
            mouse_pos = pygame.mouse.get_pos()

            # ×¢×™×‘×•×“ ××™×¨×•×¢×™ ××©×ª××©
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False

                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        self.running = False

                    # ×‘×—×™×¨×ª ×§×˜×’×•×¨×™×” ×‘××§×©×™ 1-6 (×‘××™×“×” ×•××¤×©×¨)
                    elif (self.model.selected_category is None and
                          not self.model.show_category_completed and
                          event.key in [pygame.K_1, pygame.K_2, pygame.K_3,
                                        pygame.K_4, pygame.K_5, pygame.K_6]):
                        categories = ["History", "Computer Science", "Science",
                                      "Geography", "Movies", "Sports"]
                        selected_index = event.key - pygame.K_1
                        if 0 <= selected_index < len(categories):
                            cat = categories[selected_index]
                            if self.model.is_category_available(cat):
                                self.model.selected_category = cat
                                print(f"âœ… Selected category: {cat}")
                                self.generate_next_question()

                elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    # ×× ×”××©×—×§ ×”×¡×ª×™×™× - ×‘×•×“×§×™× ×× ×œ×—×¦×• ×¢×œ Play Again ××• Quit
                    if self.model.game_over:
                        play_again_rect = pygame.Rect(self.view.WIDTH // 2 - 150, 450, 300, 60)
                        quit_rect = pygame.Rect(self.view.WIDTH // 2 - 150, 530, 300, 60)

                        if play_again_rect.collidepoint(mouse_pos):
                            # ××™×¤×•×¡ ×•× ×™×¡×™×•×Ÿ ××—×“×©
                            self.model.reset_game()
                            # × ×ª×—×™×œ ×œ×˜×¢×•×Ÿ ×©××œ×•×ª ××—×“×©
                            threading.Thread(target=self.model.preload_questions_thread).start()
                            # ×©×•×‘ ××‘×§×©×™× ×©×
                            self.model.player_name = self.get_player_name()
                        elif quit_rect.collidepoint(mouse_pos):
                            self.running = False

                    # ×× ×¡×™×™×× ×• ×§×˜×’×•×¨×™×” â€“ ××¡×š ×§×˜×’×•×¨×™×” ×”×•×©×œ××”
                    elif self.model.show_category_completed:
                        button_rect = pygame.Rect(self.view.WIDTH // 2 - 180, 450, 360, 70)
                        if (button_rect.collidepoint(mouse_pos) and
                                self.model.category_completion_timer <= 0):
                            self.model.show_category_completed = False
                            self.model.selected_category = None

                    # ×× ×× ×—× ×• ×‘××¡×š ×‘×—×™×¨×ª ×§×˜×’×•×¨×™×”
                    elif self.model.selected_category is None:
                        categories = ["History", "Computer Science", "Science",
                                      "Geography", "Movies", "Sports"]
                        for i, cat in enumerate(categories):
                            y_pos = 245 + i * 60
                            rect = pygame.Rect(290, y_pos, 350, 50)

                            if rect.collidepoint(mouse_pos) and cat not in self.model.used_categories:
                                self.model.selected_category = cat
                                print(f"âœ… Selected category: {cat}")
                                self.generate_next_question()
                                break

                    # ××—×¨×ª, ×× ×—× ×• ×‘××¡×š ×©××œ×” (×‘××©×—×§)
                    elif (self.model.current_question is not None and
                          not self.loading and
                          self.model.feedback_message is None):
                        # ×‘×“×™×§×ª ×œ×—×™×¦×” ×¢×œ ××—×ª ×”×ª×©×•×‘×•×ª
                        options = self.model.current_question[1]
                        correct_answer = self.model.current_question[2]
                        wrapped_text = self.view.wrap_text(self.model.current_question[0],
                                                           self.view.font,
                                                           self.view.WIDTH - 100)
                        # ××—×©×‘×™× ×”×™×›×Ÿ ××ª×—×™×œ×•×ª ×”××¤×©×¨×•×™×•×ª
                        answer_y_start = 105 + len(wrapped_text) * 45 + 30

                        # ×¢×‘×•×¨ ×›×œ ××•×¤×¦×™×” ×‘×•×“×§×™× ×× × ×œ×—×¥
                        for i, option in enumerate(options):
                            option_rect = pygame.Rect(40, answer_y_start - 10,
                                                      self.view.WIDTH - 80, 50)
                            if option_rect.collidepoint(mouse_pos):
                                # ×‘×“×™×§×” ×× ×–×” ×ª×©×•×‘×” × ×›×•× ×” ××• ×œ×
                                if option == correct_answer:
                                    self.model.score += 1
                                    self.model.feedback_message = "Correct!"
                                    self.model.correct_sound.play()
                                    print(f"âœ… Correct! New score: {self.model.score}")
                                else:
                                    self.model.feedback_message = f"Incorrect! The answer is: {correct_answer}"
                                    self.model.incorrect_sound.play()
                                    print(f"âŒ Wrong! Correct answer was: {correct_answer}")

                                self.model.feedback_timer = 30  # ××¦×™×’×™× ×¤×™×“×‘×§ ×œ××©×š ~1 ×©× ×™×™×”
                                self.model.waiting_for_feedback = True

                                # ×”×¤×•× ×§×¦×™×” ×”×–×• (delayed_next_question) ×ª××ª×™×Ÿ ×•××– ×ª×¤×™×§ ×©××œ×” ×—×“×©×”
                                def delayed_next_question():
                                    pygame.time.wait(1000)
                                    self.model.waiting_for_feedback = False
                                    self.generate_next_question()

                                threading.Thread(target=delayed_next_question, daemon=True).start()

                                break
                            answer_y_start += 70

            # --- ×¦×™×•×¨ ××¡×š ---

            # ×¨×§×¢
            self.view.draw_gradient_background()

            # ×× ×”××©×—×§ × ×’××¨ â€“ ××¡×š ×¡×™×•×
            if self.model.game_over:
                self.view.draw_game_over(self.model)

            # ×× ×¡×™×™×× ×• ×§×˜×’×•×¨×™×” â€“ ××¡×š ×‘×™× ×™×™×
            elif self.model.show_category_completed:
                self.view.draw_category_completed(self.model)

            # ×× ×¢×•×“ ×œ× × ×‘×—×¨×” ×§×˜×’×•×¨×™×” (××¡×š ×‘×—×™×¨×ª ×§×˜×’×•×¨×™×”)
            elif self.model.selected_category is None:
                # ×›×•×ª×¨×ª ×¢× ×©× ×”×©×—×§×Ÿ
                self.view.draw_text_centered(f"Welcome, {self.model.player_name}!",
                                             self.view.WIDTH // 2, 50,
                                             self.view.large_font, self.view.BLUE)

                # ××¦×™×’×™× ×¡×˜×˜×•×¡ ×× ×›×‘×¨ ×”×ª×—×œ× ×• ×œ×©×—×§
                if self.model.categories_completed > 0:
                    stats_box = pygame.Rect(self.view.WIDTH - 320, 20, 300, 90)
                    pygame.draw.rect(self.view.screen, (255, 255, 255, 180), stats_box, border_radius=10)
                    self.view.draw_text(f"Score: {self.model.score}/{self.model.total_questions}",
                                        self.view.WIDTH - 310, 30, self.view.font, self.view.GREEN)
                    self.view.draw_text(
                        f"Categories: {self.model.categories_completed}/{self.model.total_categories_to_play}",
                        self.view.WIDTH - 310, 70, self.view.font, self.view.BLUE
                    )

                # ×›×•×ª×¨×ª "×‘×—×¨ ×§×˜×’×•×¨×™×”"
                pygame.draw.rect(self.view.screen, self.view.WHITE, (190, 140, 620, 60), border_radius=10)
                self.view.draw_text_centered("Select a Category:",
                                             self.view.WIDTH // 2, 170,
                                             self.view.large_font, self.view.BLUE)

                # ××¦×™×’×™× ××ª ×”×§×˜×’×•×¨×™×•×ª ×›×œ×—×™×¦×•×ª
                categories = ["History", "Computer Science", "Science", "Geography", "Movies", "Sports"]
                for i, cat in enumerate(categories):
                    y_pos = 245 + i * 60
                    rect = pygame.Rect(290, y_pos, 350, 50)

                    if cat in self.model.used_categories:
                        # ×§×˜×’×•×¨×™×” ×©×›×‘×¨ ×©×•×—×§×”
                        pygame.draw.rect(self.view.screen, (0, 0, 0, 30), rect.inflate(4, 4), border_radius=5)
                        pygame.draw.rect(self.view.screen, self.view.DISABLED_COLOR, rect, border_radius=5)
                        self.view.draw_text(f"{i + 1}. {cat} (Completed)",
                                            rect.x + 10, rect.y + 5,
                                            self.view.font, self.view.DISABLED_TEXT)
                    else:
                        # ×§×˜×’×•×¨×™×” ×–××™× ×”
                        pygame.draw.rect(self.view.screen, (0, 0, 0, 50),
                                         rect.inflate(4, 4), border_radius=5)

                        if rect.collidepoint(mouse_pos):
                            pygame.draw.rect(self.view.screen, self.view.HIGHLIGHT_COLOR, rect, border_radius=5)
                        else:
                            pygame.draw.rect(self.view.screen, self.view.LIGHT_GRAY, rect, border_radius=5)

                        self.view.draw_text(f"{i + 1}. {cat}",
                                            rect.x + 10, rect.y + 5,
                                            self.view.font, self.view.BLACK)

            # ×× ×× ×—× ×• ×‘×˜×¢×™× ×ª ×©××œ×” (×œ×•×§×— ×›××” ×©× ×™×•×ª/×©×’×™××” ××¤×©×¨×™×ª)
            elif self.loading:
                self.view.draw_loading(self.model)

            else:
                # ××¡×š ×©××œ×”
                # bar ×¢×œ×™×•×Ÿ ×¢× ××™×“×¢ ×¢×œ ×”×”×ª×§×“××•×ª
                pygame.draw.rect(self.view.screen, (255, 255, 255, 180), (0, 0, self.view.WIDTH, 80))
                display_question_num = (self.model.current_category_questions
                                        if self.model.current_category_questions > 0 else 1)
                self.view.draw_text(f"Question {display_question_num}/{self.model.questions_per_category}",
                                    self.view.WIDTH - 250, 20, self.view.font)
                self.view.draw_text(f"Score: {self.model.score}",
                                    self.view.WIDTH - 150, 50,
                                    self.view.font, self.view.GREEN)
                self.view.draw_text(f"Category: {self.model.selected_category}",
                                    50, 20, self.view.font, self.view.BLUE)
                self.view.draw_text(f"Total Progress: {self.model.questions_answered}/{self.model.total_questions}",
                                    50, 50, self.view.font)

                # ×¦×™×•×¨ ×”×©××œ×” ×¢×¦××”
                self.view.draw_question(self.model.current_question, mouse_pos)

                # ×¦×™×•×¨ ×¤×™×“×‘×§ ×× ×™×©
                if self.model.feedback_message:
                    self.view.draw_feedback(self.model.feedback_message, self.model.feedback_timer)
                    self.model.feedback_timer -= 1
                    if self.model.feedback_timer <= 0:
                        self.model.feedback_message = None

            pygame.display.flip()
            self.clock.tick(30)


def main():
    """
    ×”×¤×•× ×§×¦×™×” ×”×¨××©×™×ª, ×©×™×•×¦×¨×ª ××ª ×”Ö¾Model, View, Controller ×•××¤×¢×™×œ×” ××ª ×”××©×—×§.
    """
    model = TriviaModel()
    view = TriviaView()
    controller = TriviaController(model, view)
    controller.run()
    pygame.quit()
    sys.exit()


if __name__ == "__main__":
    main()
